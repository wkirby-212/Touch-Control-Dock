<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Touch Control Dock</title>
<style>
  :root{
    --pad: 18px;
    --radius: 20px;
    --font: 18px;
    --gap: 16px;

    --bg: #050507;
    --surface: #111217;
    --surface-2: #161821;
    --text: #f5f5f7;
    --muted: #b9bcc7;
    --gold: #d7b25e;
    --gold-soft: #b8932f;

    --border: 3px solid var(--gold);
    --accent-glow: 0 0 0 2px rgba(215,178,94,0.3);
  }

  *{ box-sizing:border-box; }

  body{
    font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    margin:0;
    padding:16px;
    font-size:var(--font);
    background: radial-gradient(circle at top center,#1b1a23 0,#020204 60%,#000 100%);
    color:var(--text);
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:100vh;
  }

  h1,h2,h3{ margin:0; }

  h2{
    font-size:1.3rem;
    color:var(--gold);
  }
  h3{
    font-size:1.05rem;
  }

  .board{
    border-radius:34px;
    border:3px solid var(--gold);
    max-width:1180px;
    width:100%;
    max-height:760px;
    height:100%;
    padding:30px 34px 26px;
    background: radial-gradient(circle at top center,#191821 0,#050507 60%,#020203 100%);
    box-shadow:
      0 0 0 1px rgba(215,178,94,0.4),
      0 18px 40px rgba(0,0,0,0.7);
    display:flex;
    flex-direction:column;
  }

  .board-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }

  .board-title{
    flex:1;
    text-align:center;
    font-size:2.6rem;
    font-weight:800;
    letter-spacing:0.3em;
    text-transform:uppercase;
    color:var(--gold);
  }

  .board-conn{
    display:flex;
    align-items:center;
    gap:6px;
    font-size:0.9rem;
  }
  .conn-label{ color:var(--muted); }
  .conn-pill{
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(215,178,94,0.75);
    font-size:0.85rem;
    white-space:nowrap;
  }

  .view{
    margin-top:26px;
    flex:1;
    min-height:0;
    display:flex;
    flex-direction:column;
  }
  .view[hidden]{ display:none; }

  .home-grid{
    display:grid;
    grid-template-columns:repeat(4,1fr);
    grid-auto-rows:minmax(120px,1fr);
    gap:22px;
    flex:1;
  }

  .tile-btn{
    border-radius:26px;
    border:3px solid var(--gold);
    background: radial-gradient(circle at top,#26252e 0,#15151c 45%,#09090c 100%);
    color:var(--gold);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    text-align:center;
    font-weight:700;
    text-transform:uppercase;
    letter-spacing:0.08em;
    font-size:1.1rem;
    padding:6px 10px;
    cursor:pointer;
    transition:
      transform 80ms ease,
      box-shadow 120ms ease,
      border-color 120ms ease,
      background 120ms ease;
  }
  .tile-btn:hover{
    border-color:#ffe29c;
    box-shadow:0 0 0 2px rgba(255,226,156,0.4);
  }
  .tile-btn:active{
    transform:scale(0.97);
  }
  .tile-main{ font-size:1.4rem; }
  .tile-sub{ font-size:1.05rem; margin-top:4px; }
  .tile-icon{ font-size:1.8rem; margin-bottom:4px; }

  .panel-header{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom:12px;
  }
  .panel-body{
    flex:1;
    min-height:0;
    overflow-y:auto;
    padding-right:2px;
    display:flex;
    flex-direction:column;
    gap:16px;
  }

  .back-btn{
    border-radius:999px;
    border:2px solid rgba(215,178,94,0.8);
    background:transparent;
    padding:8px 14px;
    font-size:0.95rem;
    color:var(--gold);
    cursor:pointer;
    min-height:auto;
  }

  .card{
    border:2px solid rgba(215,178,94,0.85);
    border-radius:18px;
    padding:16px 18px;
    background:var(--surface);
    box-shadow:0 6px 18px rgba(0,0,0,0.35);
  }

  .row{
    display:flex;
    flex-wrap:wrap;
    gap:12px;
    align-items:center;
  }

  .two-col{
    display:grid;
    grid-template-columns:1fr;
    gap:var(--gap);
  }
  @media (min-width:860px){
    .two-col{ grid-template-columns:1fr 1fr; }
  }

  label{
    font-size:0.9rem;
    color:var(--muted);
  }

  input[type="text"],input[type="password"],input[type="number"],select{
    width:100%;
    border:2px solid rgba(215,178,94,0.6);
    border-radius:12px;
    padding:10px 12px;
    font-size:0.95rem;
    background:var(--surface-2);
    color:var(--text);
    outline:none;
  }
  input[type="text"]:focus,
  input[type="password"]:focus,
  input[type="number"]:focus,
  select:focus{
    box-shadow:var(--accent-glow);
  }

  button{
    border:2px solid rgba(215,178,94,0.8);
    border-radius:14px;
    padding:10px 14px;
    font-size:0.95rem;
    background:var(--surface-2);
    color:var(--text);
    cursor:pointer;
    min-height:44px;
    transition:transform 80ms ease, border-color 120ms ease, background 120ms ease, box-shadow 120ms ease;
  }
  button:hover{ border-color:var(--gold); }
  button:active{ transform:scale(0.985); }
  button[disabled]{ opacity:0.45; cursor:not-allowed; }

  button.primary{
    background:linear-gradient(135deg,rgba(215,178,94,0.18),rgba(215,178,94,0.06));
    font-weight:700;
  }
  button.small{
    padding:6px 10px;
    min-height:34px;
    font-size:0.85rem;
  }

  .status{
    margin-top:6px;
    font-size:0.9rem;
    color:var(--muted);
  }
  .hint{
    font-size:0.85rem;
    color:var(--muted);
  }

  .grid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(210px,1fr));
    gap:12px;
  }
  .fav-grid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(180px,1fr));
    gap:10px;
  }
  .live-grid{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(260px,1fr));
    gap:var(--gap);
  }

  .scene-btn{
    width:100%;
    text-align:center;
    font-weight:600;
  }

  .meter{
    width:100%;
    height:14px;
    border:2px solid rgba(215,178,94,0.6);
    border-radius:999px;
    overflow:hidden;
    background:var(--surface-2);
    margin:8px 0 10px;
  }
  .meter-bar{
    height:100%;
    width:0%;
    background:linear-gradient(90deg,var(--gold-soft),var(--gold));
    transition:width 80ms linear;
  }

  .mixer-item .name{
    font-weight:700;
    margin-bottom:6px;
  }

  input[type="range"]{
    width:100%;
    height:40px;
  }

  details.group{
    border:2px solid rgba(215,178,94,0.8);
    border-radius:18px;
    background:var(--surface);
    padding:0;
  }
  details.group > summary{
    list-style:none;
    cursor:pointer;
    padding:14px 16px;
    font-weight:700;
    background:linear-gradient(135deg,rgba(215,178,94,0.14),rgba(215,178,94,0.04));
    border-radius:16px;
  }
  details.group[open] > summary{
    border-bottom:2px solid rgba(215,178,94,0.8);
    border-bottom-left-radius:0;
    border-bottom-right-radius:0;
  }
  .group-body{
    padding:14px 16px 16px;
  }

  .checkbox-row{
    display:flex;
    flex-wrap:wrap;
    gap:10px 16px;
  }
  .checkbox{
    display:flex;
    align-items:center;
    gap:8px;
    padding:6px 8px;
    border-radius:10px;
    background:var(--surface-2);
    border:1px solid rgba(215,178,94,0.25);
    font-size:0.85rem;
  }
  .checkbox input{
    width:20px;
    height:20px;
  }

  .badge{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid rgba(215,178,94,0.5);
    font-size:0.78rem;
    color:var(--muted);
    margin-left:6px;
  }

  /* HYTE Y70 specific tweaks (via layout profile) */
  body[data-layout="y70"]{
    --pad:12px;
    --radius:18px;
    --font:16px;
    --gap:12px;
  }
  body[data-layout="y70"] .board{
    padding:18px 18px 16px;
    border-radius:26px;
  }
  body[data-layout="y70"] .board-title{
    font-size:2.1rem;
    letter-spacing:0.22em;
  }
  body[data-layout="y70"] .home-grid{
    grid-auto-rows:110px;
    gap:16px;
  }
  body[data-layout="y70"] .tile-btn{
    border-width:2px;
    border-radius:20px;
    font-size:1rem;
  }
  body[data-layout="y70"] .tile-main{ font-size:1.25rem; }
</style>
</head>
<body>
<div id="top" style="position:absolute;left:0;top:0;width:1px;height:1px;opacity:0;pointer-events:none;"></div>

<div class="board">
  <div class="board-header">
    <div class="board-title">TOUCH CONTROL DOCK</div>
    <div class="board-conn">
      <span class="conn-label">Status</span>
      <span id="connStatusHeader" class="conn-pill">Not connected.</span>
    </div>
  </div>

  <!-- Home view -->
  <section id="view-home" class="view">
    <div class="home-grid">
      <button class="tile-btn" data-view-target="view-scenes">
        <div class="tile-main">Scene</div>
      </button>
      <button class="tile-btn" data-view-target="view-live">
        <div class="tile-main">Start</div>
        <div class="tile-sub">Record / Stream</div>
      </button>
      <button class="tile-btn" data-view-target="view-mic">
        <div class="tile-main">Favourites</div>
      </button>
      <button class="tile-btn" data-view-target="view-audio">
        <div class="tile-main">Audio</div>
      </button>
      <button class="tile-btn" data-view-target="view-settings">
        <div class="tile-main">Settings</div>
      </button>
      <button class="tile-btn" data-view-target="view-virtual">
        <div class="tile-main">Virtual</div>
        <div class="tile-sub">Cam</div>
      </button>
    </div>
  </section>

  <!-- Scenes / Studio panel -->
  <section id="view-scenes" class="view" hidden>
    <div class="panel-header">
      <button class="back-btn" data-view-back>&larr; Home</button>
      <h2>Scenes &amp; Studio</h2>
    </div>
    <div class="panel-body">
      <div class="card">
        <h3>Program Scenes</h3>
        <div id="scenesQuick" class="grid"></div>
      </div>

      <div class="two-col">
        <div class="card">
          <h3>Favorite Scenes <span class="badge"><span id="favScenesCount">0</span> pinned</span></h3>
          <div id="favScenesGrid" class="fav-grid"></div>
          <div class="hint">Tap ★ on a scene card to add/remove favorites.</div>
        </div>

        <div class="card">
          <div class="row" style="justify-content:space-between;align-items:center;">
            <h3 style="margin-bottom:6px;">Studio Mode</h3>
            <button id="studioToggleBtn" class="small">Enable Studio Mode</button>
          </div>
          <div class="status" id="studioStatus">Studio Mode is disabled.</div>

          <div class="row" style="margin-top:14px;">
            <div style="flex:1 1 0;min-width:220px;">
              <h3>Preview</h3>
              <div id="previewScenes" class="grid"></div>
            </div>
            <div style="flex:1 1 0;min-width:220px;">
              <h3>Program</h3>
              <div id="programScenes" class="grid"></div>
            </div>
          </div>

          <div class="row" style="margin-top:14px;">
            <button id="takeBtn" class="primary">Take</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="row" style="align-items:flex-end;">
          <div style="flex:2 1 260px;min-width:220px;">
            <label>Default Transition</label>
            <select id="transitionSelect"></select>
          </div>
          <div style="flex:1 1 140px;min-width:150px;">
            <label>Duration (ms)</label>
            <input id="transitionDuration" type="number" min="50" step="50" />
          </div>
          <div style="flex:0 0 auto;display:flex;gap:8px;">
            <button id="applyTransitionBtn" class="small">Apply</button>
            <button id="triggerTransitionBtn" class="small primary">Cut / Transition</button>
          </div>
        </div>
        <div class="hint" style="margin-top:10px;">Quick transitions</div>
        <div id="transitionButtons" class="row" style="margin-top:6px;flex-wrap:wrap;"></div>
      </div>
    </div>
  </section>

  <!-- Live panel -->
  <section id="view-live" class="view" hidden>
    <div class="panel-header">
      <button class="back-btn" data-view-back>&larr; Home</button>
      <h2>Record &amp; Stream</h2>
    </div>
    <div class="panel-body">
      <div class="live-grid">
        <div class="card">
          <h3>Recording <span id="recordBadge" class="badge">Idle</span></h3>
          <div class="status" id="recordStatus">Not recording.</div>
          <div class="row" style="margin-top:12px;">
            <button id="recordToggleBtn" class="primary">Start Recording</button>
          </div>
        </div>
        <div class="card">
          <h3>Streaming <span id="streamBadge" class="badge">Idle</span></h3>
          <div class="status" id="streamStatus">Not streaming.</div>
          <div class="row" style="margin-top:12px;">
            <button id="streamToggleBtn" class="primary">Start Streaming</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Mic / Favorites audio panel -->
  <section id="view-mic" class="view" hidden>
    <div class="panel-header">
      <button class="back-btn" data-view-back>&larr; Home</button>
      <h2>Favourites</h2>
    </div>
    <div class="panel-body">
      <div class="card">
        <h3>Favorite Audio <span class="badge"><span id="favInputsCount">0</span> pinned</span></h3>
        <div id="favInputsGrid" class="fav-grid"></div>
        <div class="hint">Tap ★ on any audio source to add/remove favorites.</div>
      </div>
    </div>
  </section>

  <!-- Audio mixer panel -->
  <section id="view-audio" class="view" hidden>
    <div class="panel-header">
      <button class="back-btn" data-view-back>&larr; Home</button>
      <h2>Audio Mixer</h2>
    </div>
    <div class="panel-body">
      <div class="card">
        <h3>Filters</h3>
        <div id="audioFiltersHost"></div>
      </div>

      <div class="card">
        <h3>Inputs</h3>
        <div id="mixerGroups"></div>
      </div>
    </div>
  </section>

  <!-- Settings panel -->
  <section id="view-settings" class="view" hidden>
    <div class="panel-header">
      <button class="back-btn" data-view-back>&larr; Home</button>
      <h2>Settings</h2>
    </div>
    <div class="panel-body">
      <div class="card">
        <h3>Connection</h3>
        <div class="row">
          <div style="min-width:180px; flex:2 1 260px;">
            <label>Host</label>
            <input id="host" type="text" value="127.0.0.1" />
          </div>
          <div style="max-width:140px; flex:1 1 120px;">
            <label>Port</label>
            <input id="port" type="text" value="4455" />
          </div>
          <div style="min-width:220px; flex:3 1 260px;">
            <label>Password</label>
            <input id="password" type="password" placeholder="WebSocket password" />
          </div>
          <div style="max-width:180px; flex:1 1 160px;">
            <label>Layout</label>
            <select id="layoutSelect">
              <option value="auto">Auto</option>
              <option value="y70">Y70 Wide</option>
              <option value="default">Default</option>
            </select>
          </div>
          <div style="max-width:170px; flex:1 1 140px;">
            <label>&nbsp;</label>
            <button id="connectBtn" class="primary">Connect</button>
          </div>
        </div>
        <div class="status" id="connStatus">Not connected.</div>
      </div>

      <div class="card">
        <div class="two-col">
          <div>
            <h3>Scene Collections</h3>
            <div class="row">
              <select id="sceneCollectionSelect"></select>
              <button id="refreshCollectionsBtn" class="small">Refresh</button>
            </div>
            <div class="hint">Switching collections can briefly reset lists.</div>
          </div>
          <div>
            <h3>Profiles</h3>
            <div class="row">
              <select id="profileSelect"></select>
              <button id="refreshProfilesBtn" class="small">Refresh</button>
            </div>
            <div class="hint">Profiles affect output/stream settings.</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Virtual Cam placeholder -->
  <section id="view-virtual" class="view" hidden>
    <div class="panel-header">
      <button class="back-btn" data-view-back>&larr; Home</button>
      <h2>Virtual Camera</h2>
    </div>
    <div class="panel-body">
      <div class="card">
        <h3>Status <span id="virtualCamBadge" class="badge">Unknown</span></h3>
        <div class="status" id="virtualCamStatus">Virtual camera status unavailable.</div>
        <div class="row" style="margin-top:16px;">
          <button id="virtualCamToggleBtn" class="primary" style="flex:1;">Start Virtual Cam</button>
        </div>
        <div class="hint">
          This button sends a start/stop request to the OBS virtual camera. If nothing happens,
          check that the virtual camera feature is installed and enabled inside OBS.
        </div>
      </div>
    </div>
  </section>

  <!-- Exit placeholder -->
  <section id="view-exit" class="view" hidden>
    <div class="panel-header">
      <button class="back-btn" data-view-back>&larr; Home</button>
      <h2>Exit</h2>
    </div>
    <div class="panel-body">
      <div class="card">
        <div class="hint">
          This panel is just a reminder tile so you can reserve a corner of the touch panel for quickly closing or hiding docks/windows on your desktop.
        </div>
      </div>
    </div>
  </section>

</div>

<script>
(() => {
  // ---------- Elements ----------
  const hostEl = document.getElementById('host');
  const portEl = document.getElementById('port');
  const passwordEl = document.getElementById('password');
  const connectBtn = document.getElementById('connectBtn');
  const connStatus = document.getElementById('connStatus');
  const layoutSelect = document.getElementById('layoutSelect');

  const sceneCollectionSelect = document.getElementById('sceneCollectionSelect');
  const profileSelect = document.getElementById('profileSelect');
  const refreshCollectionsBtn = document.getElementById('refreshCollectionsBtn');
  const refreshProfilesBtn = document.getElementById('refreshProfilesBtn');

  const studioToggleBtn = document.getElementById('studioToggleBtn');
  const takeBtn = document.getElementById('takeBtn');
  const studioStatus = document.getElementById('studioStatus');
  const previewScenesEl = document.getElementById('previewScenes');
  const programScenesEl = document.getElementById('programScenes');

  const scenesQuickEl = document.getElementById('scenesQuick');

  const transitionSelect = document.getElementById('transitionSelect');
  const transitionDuration = document.getElementById('transitionDuration');
  const applyTransitionBtn = document.getElementById('applyTransitionBtn');
  const triggerTransitionBtn = document.getElementById('triggerTransitionBtn');
  const transitionButtons = document.getElementById('transitionButtons');

  const audioFiltersHost = document.getElementById('audioFiltersHost');
  const mixerGroupsEl = document.getElementById('mixerGroups');

  const favScenesGrid = document.getElementById('favScenesGrid');
  const favInputsGrid = document.getElementById('favInputsGrid');
  const favScenesCount = document.getElementById('favScenesCount');
  const favInputsCount = document.getElementById('favInputsCount');

  const streamToggleBtn = document.getElementById('streamToggleBtn');
  const recordToggleBtn = document.getElementById('recordToggleBtn');
  const streamBadge = document.getElementById('streamBadge');
  const recordBadge = document.getElementById('recordBadge');
  const streamStatus = document.getElementById('streamStatus');
  const recordStatus = document.getElementById('recordStatus');

  const virtualCamBadge = document.getElementById('virtualCamBadge');
  const virtualCamStatus = document.getElementById('virtualCamStatus');
  const virtualCamToggleBtn = document.getElementById('virtualCamToggleBtn');

  // ---------- Layout Profiles ----------
  const LS_LAYOUT = 'touch_control_layout';

  function applyLayoutProfile(){
    const params = new URLSearchParams(location.search);
    const forced = params.get('layout'); // e.g. ?layout=y70

    if (forced){
      document.body.dataset.layout = forced;
      localStorage.setItem(LS_LAYOUT, forced);
      if (layoutSelect) layoutSelect.value = forced;
      return;
    }

    const saved = localStorage.getItem(LS_LAYOUT) || 'auto';
    if (layoutSelect) layoutSelect.value = saved;

    if (saved && saved !== 'auto'){
      document.body.dataset.layout = saved;
      return;
    }

    const w = window.innerWidth;
    const h = window.innerHeight;
    const aspect = w / Math.max(1, h);

    if (h <= 800 && aspect >= 3.0){
      document.body.dataset.layout = 'y70';
    }else{
      document.body.dataset.layout = 'default';
    }
  }

  if (layoutSelect){
    layoutSelect.addEventListener('change', () => {
      const v = layoutSelect.value;
      localStorage.setItem(LS_LAYOUT, v);
      applyLayoutProfile();
    });
  }

  applyLayoutProfile();
  window.addEventListener('resize', applyLayoutProfile);

  // ---------- Quick Jump ----------
  function jumpTo(id){
    const el = document.getElementById(id);
    if (!el) return;
    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  function wireQuickJump(){
    const buttons = document.querySelectorAll('[data-jump]');
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-jump');
        if (id) jumpTo(id);
      });
    });
  }

  // ---------- WebSocket v5 ----------
  let ws = null;
  let identified = false;
  let reqCounter = 0;
  const pending = new Map();
  const meterBars = new Map(); // InputName -> meterBarEl

  function setStatus(txt){ connStatus.textContent = txt; }

  function wsUrl(){
    const host = hostEl.value.trim() || '127.0.0.1';
    const port = portEl.value.trim() || '4455';
    return `ws://${host}:${port}`;
  }

  function send(op, d){
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({ op, d }));
  }

  function call(requestType, requestData = {}){
    const requestId = String(++reqCounter);
    send(6, { requestType, requestId, requestData });

    return new Promise((resolve, reject) => {
      pending.set(requestId, { resolve, reject });
      setTimeout(() => {
        if (pending.has(requestId)) {
          pending.delete(requestId);
          reject(new Error(`Timeout calling ${requestType}`));
        }
      }, 6000);
    });
  }

  async function sha256Base64(str) {
    const data = new TextEncoder().encode(str);
    const hash = await crypto.subtle.digest('SHA-256', data);
    const bytes = Array.from(new Uint8Array(hash));
    const bin = bytes.map(b => String.fromCharCode(b)).join('');
    return btoa(bin);
  }

  async function makeAuth(password, salt, challenge) {
    const secret = await sha256Base64(password + salt);
    const auth = await sha256Base64(secret + challenge);
    return auth;
  }

  function identify(authentication) {
    const identifyData = {
      rpcVersion: 1,
      eventSubscriptions: 0xFFFFFFFF
    };
    if (authentication) identifyData.authentication = authentication;
    send(1, identifyData);
  }

  async function handleHello(hello) {
    const password = passwordEl.value || '';
    let auth;
    if (hello.authentication && password) {
      const { salt, challenge } = hello.authentication;
      try { auth = await makeAuth(password, salt, challenge); } catch {}
    }
    identify(auth);
  }

  function handleIdentified() {
    identified = true;
    setStatus('Connected & identified.');
    connectBtn.textContent = 'Reconnect';
    wireQuickJump();
    initialLoad();
  }

  function handleRequestResponse(d) {
    const { requestId, requestStatus, responseData } = d;
    const entry = pending.get(requestId);
    if (!entry) return;
    pending.delete(requestId);

    if (requestStatus?.result) {
      entry.resolve({ responseData });
    } else {
      entry.reject(new Error(requestStatus?.comment ?? 'Request failed'));
    }
  }

  function flattenLevels(levels){
    try{
      if (!Array.isArray(levels)) return [];
      if (levels.flat) return levels.flat(3);
      const out = [];
      for (const v of levels){
        if (Array.isArray(v)) out.push(...v);
        else out.push(v);
      }
      return out;
    }catch{
      return [];
    }
  }

  function handleEvent(eventType, eventData){
    if (eventType === 'InputVolumeMeters'){
      const inputs = eventData?.inputs ?? [];
      for (const input of inputs){
        const name = input.inputName;
        const levels = input.inputLevelsMul || input.inputLevels || input.inputLevelsDb;
        if (!levels) continue;

        let max = 0;
        const flat = flattenLevels(levels);
        for (const v of flat){
          const n = Number(v);
          if (!isNaN(n)) max = Math.max(max, n);
        }

        const pct = Math.max(0, Math.min(100, Math.round(max * 100)));
        const bar = meterBars.get(name);
        if (bar) bar.style.width = pct + '%';
      }
    }

    if (eventType === 'CurrentProgramSceneChanged' ||
        eventType === 'CurrentPreviewSceneChanged' ||
        eventType === 'StudioModeStateChanged'){
      loadStudio();
      loadScenesQuick();
      renderFavoriteScenes();
    }

    if (eventType === 'InputMuteStateChanged' || eventType === 'InputVolumeChanged'){
      renderFavoriteInputs();
    }

    if (eventType === 'StreamStateChanged' || eventType === 'RecordStateChanged'){
      loadLive();
    }

    if (eventType === 'VirtualcamStateChanged'){
      loadVirtualCamStatus();
    }
  }

  function bindSocket(){
    ws.onopen = () => setStatus('Socket open, waiting for Hello...');
    ws.onclose = () => {
      identified = false;
      setStatus('Disconnected.');
      takeBtn.disabled = true;
      studioStatus.textContent = 'Unknown.';
      streamBadge.textContent = 'Unknown';
      recordBadge.textContent = 'Unknown';
    };
    ws.onerror = () => setStatus('WebSocket error.');

    ws.onmessage = async (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.op === 0) {
        await handleHello(msg.d || {});
      } else if (msg.op === 2) {
        handleIdentified();
      } else if (msg.op === 5) {
        const { eventType, eventData } = msg.d || {};
        if (eventType) handleEvent(eventType, eventData || {});
      } else if (msg.op === 7) {
        handleRequestResponse(msg.d || {});
      }
    };
  }

  function connect(){
    try{ if (ws) ws.close(); } catch {}
    identified = false;
    reqCounter = 0;
    pending.clear();

    setStatus('Connecting...');
    ws = new WebSocket(wsUrl());
    bindSocket();
  }

  connectBtn.onclick = connect;

  // ---------- Storage ----------
  const LS_FAV_SCENES = 'touch_control_fav_scenes';
  const LS_FAV_INPUTS = 'touch_control_fav_inputs';
  const LS_GROUP_FILTER = 'touch_control_group_filter';
  const LS_GROUP_FILTER_ENABLED = 'touch_control_group_filter_enabled';

  function getFavScenes(){
    try{ return JSON.parse(localStorage.getItem(LS_FAV_SCENES) || '[]'); }
    catch{ return []; }
  }
  function setFavScenes(arr){
    localStorage.setItem(LS_FAV_SCENES, JSON.stringify(Array.from(new Set(arr))));
  }
  function toggleFavScene(name){
    const favs = new Set(getFavScenes());
    favs.has(name) ? favs.delete(name) : favs.add(name);
    setFavScenes([...favs]);
    renderFavoriteScenes();
    loadScenesQuick();
    loadStudio();
  }

  function getFavInputs(){
    try{ return JSON.parse(localStorage.getItem(LS_FAV_INPUTS) || '[]'); }
    catch{ return []; }
  }
  function setFavInputs(arr){
    localStorage.setItem(LS_FAV_INPUTS, JSON.stringify(Array.from(new Set(arr))));
  }
  function toggleFavInput(name){
    const favs = new Set(getFavInputs());
    favs.has(name) ? favs.delete(name) : favs.add(name);
    setFavInputs([...favs]);
    renderFavoriteInputs();
    loadAudio();
  }

  function getGroupFilterEnabled(){
    return localStorage.getItem(LS_GROUP_FILTER_ENABLED) === 'true';
  }
  function setGroupFilterEnabled(val){
    localStorage.setItem(LS_GROUP_FILTER_ENABLED, val ? 'true' : 'false');
  }
  function getSelectedGroups(){
    try{ return JSON.parse(localStorage.getItem(LS_GROUP_FILTER) || '[]'); }
    catch{ return []; }
  }
  function setSelectedGroups(arr){
    localStorage.setItem(LS_GROUP_FILTER, JSON.stringify(Array.from(new Set(arr))));
  }

  // ---------- Scene Collections / Profiles ----------
  async function loadSceneCollections(){
    sceneCollectionSelect.innerHTML = '';
    let current = null;
    let list = [];

    try{
      const r = await call('GetCurrentSceneCollection');
      current = r.responseData?.currentSceneCollectionName;
    }catch{}

    try{
      const r = await call('GetSceneCollectionList');
      list = r.responseData?.sceneCollections ?? r.responseData?.sceneCollectionNames ?? [];
    }catch{}

    const names = [];
    for (const x of list){
      if (typeof x === 'string') names.push(x);
      else if (x?.sceneCollectionName) names.push(x.sceneCollectionName);
      else if (x?.name) names.push(x.name);
    }

    for (const name of names){
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      if (name === current) opt.selected = true;
      sceneCollectionSelect.appendChild(opt);
    }
  }

  async function loadProfiles(){
    profileSelect.innerHTML = '';
    let current = null;
    let list = [];

    try{
      const r = await call('GetCurrentProfile');
      current = r.responseData?.currentProfileName;
    }catch{}

    try{
      const r = await call('GetProfileList');
      list = r.responseData?.profiles ?? r.responseData?.profileNames ?? [];
    }catch{}

    const names = [];
    for (const x of list){
      if (typeof x === 'string') names.push(x);
      else if (x?.profileName) names.push(x.profileName);
      else if (x?.name) names.push(x.name);
    }

    for (const name of names){
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      if (name === current) opt.selected = true;
      profileSelect.appendChild(opt);
    }
  }

  sceneCollectionSelect.onchange = async () => {
    const name = sceneCollectionSelect.value;
    if (!name) return;
    try{ await call('SetCurrentSceneCollection', { sceneCollectionName: name }); }
    catch{
      try{ await call('SetCurrentSceneCollection', { sceneCollection: name }); } catch {}
    }
    initialLoad();
  };

  profileSelect.onchange = async () => {
    const name = profileSelect.value;
    if (!name) return;
    try{ await call('SetCurrentProfile', { profileName: name }); }
    catch{
      try{ await call('SetCurrentProfile', { profile: name }); } catch {}
    }
  };

  refreshCollectionsBtn.onclick = loadSceneCollections;
  refreshProfilesBtn.onclick = loadProfiles;

  // ---------- Live Controls ----------
  async function loadStreamStatus(){
    let active = false;
    let reconnecting = false;
    let timecode = null;

    try{
      const r = await call('GetStreamStatus');
      active = !!r.responseData?.outputActive;
      reconnecting = !!r.responseData?.outputReconnecting;
      timecode = r.responseData?.outputTimecode;
    }catch{
      try{
        const r = await call('GetOutputStatus', { outputName: 'stream' });
        active = !!r.responseData?.outputActive;
        reconnecting = !!r.responseData?.outputReconnecting;
        timecode = r.responseData?.outputTimecode;
      }catch{}
    }

    streamBadge.textContent = active ? (reconnecting ? 'Reconnecting' : 'Live') : 'Off';
    streamToggleBtn.textContent = active ? 'Stop Stream' : 'Start Stream';
    streamStatus.textContent = timecode ? `Time: ${timecode}` : '';
    return active;
  }

  async function loadRecordStatus(){
    let active = false;
    let paused = false;
    let timecode = null;

    try{
      const r = await call('GetRecordStatus');
      active = !!r.responseData?.outputActive;
      paused = !!r.responseData?.outputPaused;
      timecode = r.responseData?.outputTimecode;
    }catch{
      try{
        const r = await call('GetOutputStatus', { outputName: 'record' });
        active = !!r.responseData?.outputActive;
        paused = !!r.responseData?.outputPaused;
        timecode = r.responseData?.outputTimecode;
      }catch{}
    }

    recordBadge.textContent = active ? (paused ? 'Paused' : 'Recording') : 'Off';
    recordToggleBtn.textContent = active ? 'Stop Record' : 'Start Record';
    recordStatus.textContent = timecode ? `Time: ${timecode}` : '';
    return active;
  }

  async function loadLive(){
    if (!identified) return;
    await Promise.allSettled([loadStreamStatus(), loadRecordStatus()]);
  }

  // ---------- Virtual Cam ----------
  async function loadVirtualCamStatus(){
    if (!identified || !virtualCamBadge || !virtualCamToggleBtn || !virtualCamStatus) return;

    let active = false;
    let timecode = null;

    try{
      const r = await call('GetVirtualCamStatus');
      active = !!(r.responseData && r.responseData.outputActive);
      timecode = r.responseData && r.responseData.outputTimecode;
    }catch(e){
      console.error(e);
    }

    virtualCamBadge.textContent = active ? 'On' : 'Off';
    virtualCamToggleBtn.textContent = active ? 'Stop Virtual Cam' : 'Start Virtual Cam';
    virtualCamStatus.textContent = timecode ? `Time: ${timecode}` : (active ? 'Virtual camera is running.' : 'Virtual camera is stopped.');
    return active;
  }

  if (virtualCamToggleBtn){
    virtualCamToggleBtn.onclick = async () => {
      if (!identified) return;
      let active = false;
      try{ active = await loadVirtualCamStatus(); }catch(e){ console.error(e); }
      try{
        if (active) await call('StopVirtualCam');
        else await call('StartVirtualCam');
      }catch(e){ console.error(e); }
      loadVirtualCamStatus();
    };
  }


  streamToggleBtn.onclick = async () => {
    if (!identified) return;
    let active = false;
    try{ active = await loadStreamStatus(); }catch{}
    try{
      if (active) await call('StopStream');
      else await call('StartStream');
    }catch(e){ console.error(e); }
    loadStreamStatus();
  };

  recordToggleBtn.onclick = async () => {
    if (!identified) return;
    let active = false;
    try{ active = await loadRecordStatus(); }catch{}
    try{
      if (active) await call('StopRecord');
      else await call('StartRecord');
    }catch(e){ console.error(e); }
    loadRecordStatus();
  };

  // ---------- Scenes ----------
  function makeSceneCard(name, isFav){
    const card = document.createElement('div');
    card.className = 'card';

    const head = document.createElement('div');
    head.className = 'head-row';

    const btn = document.createElement('button');
    btn.className = 'scene-btn primary';
    btn.textContent = name;
    btn.onclick = async () => {
      try{ await call('SetCurrentProgramScene', { sceneName: name }); } catch {}
    };

    const starBtn = document.createElement('button');
    starBtn.className = 'star tiny';
    starBtn.textContent = isFav ? '★' : '☆';
    starBtn.title = isFav ? 'Remove favorite' : 'Add favorite';
    starBtn.onclick = () => toggleFavScene(name);

    head.appendChild(btn);
    head.appendChild(starBtn);
    card.appendChild(head);
    return card;
  }

  async function loadScenesQuick(){
    scenesQuickEl.innerHTML = '';
    let scenes = [];
    try{
      const r = await call('GetSceneList');
      scenes = r.responseData?.scenes ?? [];
    }catch{}

    const favSet = new Set(getFavScenes());
    for (const sc of scenes){
      const name = sc.sceneName;
      scenesQuickEl.appendChild(makeSceneCard(name, favSet.has(name)));
    }
    renderFavoriteScenes();
  }

  async function renderFavoriteScenes(){
    favScenesGrid.innerHTML = '';
    let scenes = [];
    try{
      const r = await call('GetSceneList');
      scenes = r.responseData?.scenes ?? [];
    }catch{}

    const favs = getFavScenes();
    favScenesCount.textContent = String(favs.length);

    if (favs.length === 0){
      favScenesGrid.innerHTML = '<div class="hint">No favorite scenes yet.</div>';
      return;
    }

    const sceneNames = new Set(scenes.map(s => s.sceneName));
    const ordered = favs.filter(n => sceneNames.has(n));

    for (const name of ordered){
      const card = document.createElement('div');
      card.className = 'card';

      const head = document.createElement('div');
      head.className = 'head-row';

      const btn = document.createElement('button');
      btn.className = 'scene-btn primary';
      btn.textContent = name;
      btn.onclick = async () => {
        try{ await call('SetCurrentProgramScene', { sceneName: name }); } catch {}
      };

      const starBtn = document.createElement('button');
      starBtn.className = 'star tiny';
      starBtn.textContent = '★';
      starBtn.title = 'Remove favorite';
      starBtn.onclick = () => toggleFavScene(name);

      head.appendChild(btn);
      head.appendChild(starBtn);
      card.appendChild(head);
      favScenesGrid.appendChild(card);
    }
  }

  // ---------- Studio Mode ----------
  async function loadStudio(){
    if (!identified) return;

    let enabled = false;
    try{
      const r = await call('GetStudioModeEnabled');
      enabled = !!r.responseData?.studioModeEnabled;
    }catch{}

    studioToggleBtn.textContent = enabled ? 'Disable Studio Mode' : 'Enable Studio Mode';
    studioStatus.textContent = enabled ? 'Studio Mode is enabled.' : 'Studio Mode is disabled.';
    takeBtn.disabled = !enabled;

    let scenes = [];
    try{
      const r = await call('GetSceneList');
      scenes = r.responseData?.scenes ?? [];
    }catch{}

    let currentProgram = null;
    let currentPreview = null;

    try{
      const r = await call('GetCurrentProgramScene');
      currentProgram = r.responseData?.currentProgramSceneName;
    }catch{}

    if (enabled){
      try{
        const r = await call('GetCurrentPreviewScene');
        currentPreview = r.responseData?.currentPreviewSceneName;
      }catch{}
    }

    const favSet = new Set(getFavScenes());

    previewScenesEl.innerHTML = '';
    programScenesEl.innerHTML = '';

    for (const sc of scenes){
      const name = sc.sceneName;

      const pWrap = document.createElement('div');
      pWrap.className = 'card';
      const pHead = document.createElement('div');
      pHead.className = 'head-row';

      const pBtn = document.createElement('button');
      pBtn.className = 'scene-btn';
      pBtn.textContent = name + (name === currentPreview ? ' •' : '');
      pBtn.disabled = !enabled;
      pBtn.onclick = async () => {
        try{ await call('SetCurrentPreviewScene', { sceneName: name }); } catch {}
      };

      const pStar = document.createElement('button');
      pStar.className = 'star tiny';
      pStar.textContent = favSet.has(name) ? '★' : '☆';
      pStar.onclick = () => toggleFavScene(name);

      pHead.appendChild(pBtn);
      pHead.appendChild(pStar);
      pWrap.appendChild(pHead);
      previewScenesEl.appendChild(pWrap);

      const prWrap = document.createElement('div');
      prWrap.className = 'card';
      const prHead = document.createElement('div');
      prHead.className = 'head-row';

      const prBtn = document.createElement('button');
      prBtn.className = 'scene-btn primary';
      prBtn.textContent = name + (name === currentProgram ? ' •' : '');
      prBtn.onclick = async () => {
        try{ await call('SetCurrentProgramScene', { sceneName: name }); } catch {}
      };

      const prStar = document.createElement('button');
      prStar.className = 'star tiny';
      prStar.textContent = favSet.has(name) ? '★' : '☆';
      prStar.onclick = () => toggleFavScene(name);

      prHead.appendChild(prBtn);
      prHead.appendChild(prStar);
      prWrap.appendChild(prHead);
      programScenesEl.appendChild(prWrap);
    }
  }

  studioToggleBtn.onclick = async () => {
    try{
      const r = await call('GetStudioModeEnabled');
      const enabled = !!r.responseData?.studioModeEnabled;
      await call('SetStudioModeEnabled', { studioModeEnabled: !enabled });
      loadStudio();
    }catch(e){ console.error(e); }
  };

  takeBtn.onclick = async () => {
    try{ await call('TriggerStudioModeTransition'); }
    catch(e){ console.error(e); }
  };

  // ---------- Transitions ----------
  async function loadTransitions(){
    transitionSelect.innerHTML = '';
    transitionButtons.innerHTML = '';

    let transitions = [];
    let currentName = null;
    let currentDuration = null;

    try{
      const r = await call('GetCurrentSceneTransition');
      currentName = r.responseData?.transitionName;
    }catch{}

    try{
      const r = await call('GetCurrentSceneTransitionDuration');
      currentDuration = r.responseData?.transitionDuration;
    }catch{}

    if (currentDuration != null){
      transitionDuration.value = String(currentDuration);
    }

    try{
      let r;
      try{
        r = await call('GetSceneTransitionList');
        transitions = r.responseData?.transitions ?? [];
      }catch{
        r = await call('GetTransitionList');
        transitions = r.responseData?.transitions ?? [];
      }
    }catch{}

    for (const t of transitions){
      const name = t.transitionName || t.name;
      if (!name) continue;

      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      if (name === currentName) opt.selected = true;
      transitionSelect.appendChild(opt);

      const btn = document.createElement('button');
      btn.className = 'small';
      btn.textContent = name;
      btn.onclick = async () => {
        try{
          await call('SetCurrentSceneTransition', { transitionName: name });
          transitionSelect.value = name;
        }catch(e){ console.error(e); }
      };
      transitionButtons.appendChild(btn);
    }
  }

  applyTransitionBtn.onclick = async () => {
    const name = transitionSelect.value;
    const dur = Number(transitionDuration.value || '0');
    try{ if (name) await call('SetCurrentSceneTransition', { transitionName: name }); }
    catch(e){ console.error(e); }
    try{ await call('SetCurrentSceneTransitionDuration', { transitionDuration: dur }); }
    catch(e){ console.error(e); }
  };

  triggerTransitionBtn.onclick = async () => {
    try{ await call('TriggerStudioModeTransition'); }
    catch(e){ console.error(e); }
  };

  // ---------- Audio grouping + filter ----------
  async function getAudioCapableInputs(){
    const resp = await call('GetInputList');
    const inputs = resp.responseData?.inputs ?? [];
    const out = [];

    for (const input of inputs){
      const name = input.inputName;
      let currentMul = null;
      let canMute = false;

      try{
        const vol = await call('GetInputVolume', { inputName: name });
        currentMul = vol.responseData?.inputVolumeMul ?? 1.0;
      }catch{}

      try{
        await call('GetInputMute', { inputName: name });
        canMute = true;
      }catch{}

      if (currentMul === null && !canMute) continue;

      out.push({ name, currentMul: currentMul ?? 1.0, canMute });
    }
    return out;
  }

  async function tryGetGroupList(){
    try{
      const resp = await call('GetGroupList');
      return resp.responseData?.groups ?? [];
    }catch{
      return [];
    }
  }

  async function tryGetGroupItems(groupName){
    try{
      const r1 = await call('GetGroupSceneItemList', { groupName });
      return r1.responseData?.sceneItems ?? [];
    }catch{
      try{
        const r2 = await call('GetGroupSceneItemList', { sceneName: groupName });
        return r2.responseData?.sceneItems ?? [];
      }catch{
        return [];
      }
    }
  }

  async function buildGroupMap(){
    const groups = await tryGetGroupList();
    const map = new Map();
    for (const g of groups){
      const items = await tryGetGroupItems(g);
      const names = new Set();
      for (const it of items){
        const sn = it.sourceName || it.sceneItemSourceName || it.inputName;
        if (sn) names.add(sn);
      }
      map.set(g, names);
    }
    return map;
  }

  function assignInputsToGroups(inputs, groupMap){
    const assignments = new Map();
    for (const g of groupMap.keys()){
      assignments.set(g, []);
    }
    assignments.set('Ungrouped', []);

    for (const inp of inputs){
      let placed = false;
      for (const [g, setNames] of groupMap.entries()){
        if (setNames.has(inp.name)){
          assignments.get(g).push(inp);
          placed = true;
          break;
        }
      }
      if (!placed) assignments.get('Ungrouped').push(inp);
    }

    for (const [g, arr] of Array.from(assignments.entries())){
      if (g !== 'Ungrouped' && (!arr || arr.length === 0)){
        assignments.delete(g);
      }
    }
    return assignments;
  }

  function filterAssignments(assignments){
    if (!getGroupFilterEnabled()) return assignments;
    const selected = new Set(getSelectedGroups());
    if (selected.size === 0) return assignments;

    const filtered = new Map();
    for (const [g, arr] of assignments.entries()){
      if (g === 'Ungrouped') continue;
      if (selected.has(g)) filtered.set(g, arr);
    }
    return filtered;
  }

  function renderAudioFilters(assignments){
    audioFiltersHost.innerHTML = '';

    const allGroups = Array.from(assignments.keys()).filter(g => g !== 'Ungrouped');
    const selected = new Set(getSelectedGroups());
    const enabled = getGroupFilterEnabled();

    const card = document.createElement('div');
    card.className = 'card filter-card';

    const head = document.createElement('div');
    head.className = 'row';
    head.style.justifyContent = 'space-between';

    const left = document.createElement('div');
    left.style.flex = '3 1 320px';

    const title = document.createElement('h3');
    title.style.margin = '0';
    title.textContent = 'Audio Group Filter';

    const hint = document.createElement('div');
    hint.className = 'hint';
    hint.textContent = 'Enable to show only the groups you pick. Great for cast-only tablet views.';

    left.appendChild(title);
    left.appendChild(hint);

    const right = document.createElement('div');
    right.style.flex = '1 1 220px';

    const toggleBtn = document.createElement('button');
    toggleBtn.className = enabled ? 'primary' : '';
    toggleBtn.textContent = enabled ? 'Filter: ON' : 'Filter: OFF';
    toggleBtn.onclick = () => {
      setGroupFilterEnabled(!enabled);
      loadAudio();
    };
    right.appendChild(toggleBtn);

    head.appendChild(left);
    head.appendChild(right);
    card.appendChild(head);

    if (allGroups.length === 0){
      const none = document.createElement('div');
      none.className = 'hint';
      none.style.marginTop = '10px';
      none.textContent = 'No source groups found in this setup.';
      card.appendChild(none);
      audioFiltersHost.appendChild(card);
      return;
    }

    const boxRow = document.createElement('div');
    boxRow.className = 'checkbox-row';
    boxRow.style.marginTop = '12px';

    for (const g of allGroups){
      const wrap = document.createElement('label');
      wrap.className = 'checkbox';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = selected.has(g);
      cb.onchange = () => {
        const newSel = new Set(getSelectedGroups());
        cb.checked ? newSel.add(g) : newSel.delete(g);
        setSelectedGroups([...newSel]);
        if (getGroupFilterEnabled()){
          loadAudio();
        }
      };

      const span = document.createElement('span');
      span.textContent = g;

      wrap.appendChild(cb);
      wrap.appendChild(span);
      boxRow.appendChild(wrap);
    }

    const tools = document.createElement('div');
    tools.className = 'row';
    tools.style.marginTop = '12px';

    const allBtn = document.createElement('button');
    allBtn.className = 'small';
    allBtn.textContent = 'Select All';
    allBtn.onclick = () => {
      setSelectedGroups(allGroups);
      setGroupFilterEnabled(true);
      loadAudio();
    };

    const noneBtn = document.createElement('button');
    noneBtn.className = 'small';
    noneBtn.textContent = 'Clear';
    noneBtn.onclick = () => {
      setSelectedGroups([]);
      loadAudio();
    };

    tools.appendChild(allBtn);
    tools.appendChild(noneBtn);

    card.appendChild(boxRow);
    card.appendChild(tools);
    audioFiltersHost.appendChild(card);
  }

  function createMixerCard(inputObj){
    const { name, currentMul, canMute } = inputObj;
    const isFav = new Set(getFavInputs()).has(name);

    const card = document.createElement('div');
    card.className = 'card mixer-item';

    const head = document.createElement('div');
    head.className = 'head-row';

    const title = document.createElement('div');
    title.className = 'name';
    title.textContent = name;

    const starBtn = document.createElement('button');
    starBtn.className = 'star tiny';
    starBtn.textContent = isFav ? '★' : '☆';
    starBtn.title = isFav ? 'Remove favorite' : 'Add favorite';
    starBtn.onclick = () => toggleFavInput(name);

    head.appendChild(title);
    head.appendChild(starBtn);
    card.appendChild(head);

    const meter = document.createElement('div');
    meter.className = 'meter';
    const bar = document.createElement('div');
    bar.className = 'meter-bar';
    meter.appendChild(bar);
    card.appendChild(meter);
    meterBars.set(name, bar);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = '0';
    slider.max = '200';
    slider.value = String(Math.round(currentMul * 100));
    card.appendChild(slider);

    const btnRow = document.createElement('div');
    btnRow.className = 'row';

    const muteBtn = document.createElement('button');
    muteBtn.textContent = 'Mute / Unmute';
    muteBtn.disabled = !canMute;

    const zeroBtn = document.createElement('button');
    zeroBtn.textContent = '0%';
    zeroBtn.className = 'small';

    const hundredBtn = document.createElement('button');
    hundredBtn.textContent = '100%';
    hundredBtn.className = 'small';

    const boostBtn = document.createElement('button');
    boostBtn.textContent = '150%';
    boostBtn.className = 'small';

    btnRow.appendChild(muteBtn);
    btnRow.appendChild(zeroBtn);
    btnRow.appendChild(hundredBtn);
    btnRow.appendChild(boostBtn);
    card.appendChild(btnRow);

    muteBtn.onclick = async () => {
      if (!canMute) return;
      try{ await call('ToggleInputMute', { inputName: name }); }
      catch(e){ console.error(e); }
    };

    function setSliderMul(mul){
      const v = Math.max(0, Math.min(2, mul));
      slider.value = String(Math.round(v * 100));
      return v;
    }

    zeroBtn.onclick = async () => {
      const mul = setSliderMul(0);
      try{ await call('SetInputVolume', { inputName: name, inputVolumeMul: mul }); } catch {}
      renderFavoriteInputs();
    };
    hundredBtn.onclick = async () => {
      const mul = setSliderMul(1);
      try{ await call('SetInputVolume', { inputName: name, inputVolumeMul: mul }); } catch {}
      renderFavoriteInputs();
    };
    boostBtn.onclick = async () => {
      const mul = setSliderMul(1.5);
      try{ await call('SetInputVolume', { inputName: name, inputVolumeMul: mul }); } catch {}
      renderFavoriteInputs();
    };

    let volTimer = null;
    slider.oninput = () => {
      clearTimeout(volTimer);
      volTimer = setTimeout(async () => {
        const mul = Math.max(0, Math.min(2, Number(slider.value) / 100));
        try{ await call('SetInputVolume', { inputName: name, inputVolumeMul: mul }); }
        catch(e){ console.error(e); }
        renderFavoriteInputs();
      }, 140);
    };

    return card;
  }

  function wireGroupAccordion(){
    const groups = Array.from(document.querySelectorAll('details.group'));
    groups.forEach(g => {
      g.addEventListener('toggle', () => {
        if (!g.open) return;
        groups.forEach(other => {
          if (other !== g) other.open = false;
        });
      });
    });
  }

  function renderAudioGroups(assignments){
    mixerGroupsEl.innerHTML = '';

    const filteredAssignments = filterAssignments(assignments);
    const groupEntries = Array.from(filteredAssignments.entries());

    if (groupEntries.length === 0){
      mixerGroupsEl.innerHTML = '<div class="hint">No audio inputs match the current filter.</div>';
      return;
    }

    for (const [groupName, inputs] of groupEntries){
      const details = document.createElement('details');
      details.className = 'group';
      details.open = (groupEntries.length === 1);

      const summary = document.createElement('summary');
      summary.textContent = `${groupName} (${inputs.length})`;
      details.appendChild(summary);

      const body = document.createElement('div');
      body.className = 'group-body';

      const grid = document.createElement('div');
      grid.className = 'grid';

      for (const inp of inputs){
        grid.appendChild(createMixerCard(inp));
      }

      body.appendChild(grid);
      details.appendChild(body);
      mixerGroupsEl.appendChild(details);
    }

    wireGroupAccordion();
  }

  async function loadAudio(){
    if (!identified) return;

    meterBars.clear();
    audioFiltersHost.innerHTML = '';
    mixerGroupsEl.innerHTML = '<div class="hint">Loading audio inputs...</div>';

    let inputs;
    try{ inputs = await getAudioCapableInputs(); }
    catch{
      mixerGroupsEl.innerHTML = '<div class="hint">Could not load inputs.</div>';
      return;
    }

    let groupMap = new Map();
    try{ groupMap = await buildGroupMap(); } catch {}

    const assignments = assignInputsToGroups(inputs, groupMap);

    renderAudioFilters(assignments);
    renderAudioGroups(assignments);

    renderFavoriteInputs(inputs);
  }

  // ---------- Favorite Audio Panel ----------
  function makeFavInputCard(inputObj){
    const { name, currentMul, canMute } = inputObj;

    const card = document.createElement('div');
    card.className = 'card';

    const head = document.createElement('div');
    head.className = 'head-row';

    const title = document.createElement('div');
    title.className = 'name';
    title.textContent = name;

    const starBtn = document.createElement('button');
    starBtn.className = 'star tiny';
    starBtn.textContent = '★';
    starBtn.title = 'Remove favorite';
    starBtn.onclick = () => toggleFavInput(name);

    head.appendChild(title);
    head.appendChild(starBtn);
    card.appendChild(head);

    const meter = document.createElement('div');
    meter.className = 'meter';
    const bar = document.createElement('div');
    bar.className = 'meter-bar';
    meter.appendChild(bar);
    card.appendChild(meter);
    meterBars.set(name, bar);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = '0';
    slider.max = '200';
    slider.value = String(Math.round((currentMul ?? 1) * 100));
    card.appendChild(slider);

    const row = document.createElement('div');
    row.className = 'row';

    const muteBtn = document.createElement('button');
    muteBtn.textContent = 'Mute';
    muteBtn.disabled = !canMute;

    const unmuteBtn = document.createElement('button');
    unmuteBtn.textContent = 'Unmute';
    unmuteBtn.disabled = !canMute;

    row.appendChild(muteBtn);
    row.appendChild(unmuteBtn);
    card.appendChild(row);

    muteBtn.onclick = async () => {
      try{ await call('SetInputMute', { inputName: name, inputMuted: true }); } catch {}
    };
    unmuteBtn.onclick = async () => {
      try{ await call('SetInputMute', { inputName: name, inputMuted: false }); } catch {}
    };

    let volTimer = null;
    slider.oninput = () => {
      clearTimeout(volTimer);
      volTimer = setTimeout(async () => {
        const mul = Math.max(0, Math.min(2, Number(slider.value) / 100));
        try{ await call('SetInputVolume', { inputName: name, inputVolumeMul: mul }); }
        catch(e){ console.error(e); }
      }, 140);
    };

    return card;
  }

  async function renderFavoriteInputs(preFetchedInputs){
    favInputsGrid.innerHTML = '';
    const favs = getFavInputs();
    favInputsCount.textContent = String(favs.length);

    if (favs.length === 0){
      favInputsGrid.innerHTML = '<div class="hint">No favorite audio sources yet.</div>';
      return;
    }

    let inputs = preFetchedInputs;
    if (!inputs){
      try{ inputs = await getAudioCapableInputs(); } catch { inputs = []; }
    }

    const byName = new Map(inputs.map(i => [i.name, i]));
    const ordered = favs.filter(n => byName.has(n));

    if (ordered.length === 0){
      favInputsGrid.innerHTML = '<div class="hint">Favorites not found in current inputs.</div>';
      return;
    }

    for (const name of ordered){
      favInputsGrid.appendChild(makeFavInputCard(byName.get(name)));
    }
  }

  // ---------- Initial load ----------
  async function initialLoad(){
    if (!identified) return;

    await Promise.allSettled([
      loadSceneCollections(),
      loadProfiles(),
      loadLive(),
      loadTransitions(),
      loadScenesQuick(),
      loadStudio(),
      loadAudio(),
      loadVirtualCamStatus()
    ]);

    renderFavoriteScenes();
  }

})();
</script>
<script>
(() => {
  const views = Array.from(document.querySelectorAll('.view'));
  let currentId = 'view-home';

  function showView(id){
    currentId = id;
    views.forEach(v => {
      if (v.id === id) {
        v.removeAttribute('hidden');
      } else {
        v.setAttribute('hidden','');
      }
    });
  }

  // Tile buttons
  document.querySelectorAll('.tile-btn[data-view-target]').forEach(btn => {
    btn.addEventListener('click', () => {
      const target = btn.getAttribute('data-view-target');
      if (target) showView(target);
    });
  });

  // Back buttons
  document.querySelectorAll('[data-view-back]').forEach(btn => {
    btn.addEventListener('click', () => showView('view-home'));
  });

  // expose helper in case we ever need it from console
  window.touchDockShowView = showView;

  // initial
  showView('view-home');
})();
</script>
<script>
// Mirror connection status text into the header pill
(() => {
  const main = document.getElementById('connStatus');
  const pill = document.getElementById('connStatusHeader');
  if (!main || !pill) return;
  const sync = () => { pill.textContent = main.textContent || ' '; };
  const obs = new MutationObserver(sync);
  obs.observe(main, { childList:true, subtree:true, characterData:true });
  sync();
})();
</script>

</body>
</html>
